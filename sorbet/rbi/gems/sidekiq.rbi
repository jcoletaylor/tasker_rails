# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq/all/sidekiq.rbi
#
# sidekiq-7.0.9

module Sidekiq
  def self.configure_client; end
  def self.configure_embed(&block); end
  def self.configure_server(&block); end
  def self.default_configuration; end
  def self.default_job_options; end
  def self.default_job_options=(hash); end
  def self.dump_json(object); end
  def self.ent?; end
  def self.freeze!; end
  def self.load_json(string); end
  def self.logger; end
  def self.pro?; end
  def self.redis(&block); end
  def self.redis_pool; end
  def self.server?; end
  def self.strict_args!(mode = nil); end
  def self.transactional_push!; end
end
class Sidekiq::RedisClientAdapter
  def client_opts(options); end
  def initialize(options); end
  def new_client; end
end
module Sidekiq::RedisClientAdapter::CompatMethods
  def evalsha(sha, keys, argv); end
  def info; end
  def method_missing(*args, &block); end
  def respond_to_missing?(name, include_private = nil); end
end
class Sidekiq::RedisClientAdapter::CompatClient < RedisClient::Decorator::Client
  def config; end
  def message; end
  def subscribe(chan); end
  include Sidekiq::RedisClientAdapter::CompatMethods
end
class Sidekiq::RedisClientAdapter::CompatClient::Pipeline < RedisClient::Decorator::Pipeline
  include Sidekiq::RedisClientAdapter::CompatMethods
end
module Sidekiq::RedisConnection
  def self.create(options = nil); end
  def self.determine_redis_provider; end
  def self.scrub(options); end
end
class Sidekiq::Config
  def [](*args, &block); end
  def []=(*args, &block); end
  def average_scheduled_poll_interval=(interval); end
  def capsule(name); end
  def capsules; end
  def client_middleware; end
  def concurrency; end
  def concurrency=(val); end
  def death_handlers; end
  def default_capsule(&block); end
  def error_handlers; end
  def fetch(*args, &block); end
  def handle_exception(ex, ctx = nil); end
  def has_key?(*args, &block); end
  def initialize(options = nil); end
  def key?(*args, &block); end
  def local_redis_pool; end
  def logger; end
  def logger=(logger); end
  def lookup(name, default_class = nil); end
  def merge!(*args, &block); end
  def new_redis_pool(size, name = nil); end
  def on(event, &block); end
  def queues; end
  def queues=(val); end
  def redis; end
  def redis=(hash); end
  def redis_info; end
  def redis_pool; end
  def register(name, instance); end
  def server_middleware; end
  def total_concurrency; end
  extend Forwardable
end
module Sidekiq::Context
  def self.add(k, v); end
  def self.current; end
  def self.with(hash); end
end
module Sidekiq::LoggingUtils
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def log_at(level); end
  def warn?; end
end
class Sidekiq::Logger < Logger
  include Sidekiq::LoggingUtils
end
module Sidekiq::Logger::Formatters
end
class Sidekiq::Logger::Formatters::Base < Logger::Formatter
  def ctx; end
  def format_context; end
  def tid; end
end
class Sidekiq::Logger::Formatters::Pretty < Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end
class Sidekiq::Logger::Formatters::WithoutTimestamp < Sidekiq::Logger::Formatters::Pretty
  def call(severity, time, program_name, message); end
end
class Sidekiq::Logger::Formatters::JSON < Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end
module Sidekiq::ServerMiddleware
  def config; end
  def config=(arg0); end
  def logger; end
  def redis(&block); end
  def redis_pool; end
end
module Sidekiq::Middleware
end
class Sidekiq::Middleware::Chain
  def add(klass, *args); end
  def clear; end
  def copy_for(capsule); end
  def each(&block); end
  def empty?; end
  def entries; end
  def exists?(klass); end
  def include?(klass); end
  def initialize(config = nil); end
  def insert_after(oldklass, newklass, *args); end
  def insert_before(oldklass, newklass, *args); end
  def invoke(*args, &block); end
  def prepend(klass, *args); end
  def remove(klass); end
  def retrieve; end
  def traverse(chain, index, args, &block); end
  include Enumerable
end
class Sidekiq::Middleware::Entry
  def initialize(config, klass, *args); end
  def klass; end
  def make_new; end
end
module Sidekiq::JobUtil
  def json_unsafe?(item); end
  def normalize_item(item); end
  def normalized_hash(item_class); end
  def validate(item); end
  def verify_json(item); end
end
class Sidekiq::Client
  def atomic_push(conn, payloads); end
  def initialize(*args, **kwargs); end
  def middleware(&block); end
  def push(item); end
  def push_bulk(items); end
  def raw_push(payloads); end
  def redis_pool; end
  def redis_pool=(arg0); end
  def self.enqueue(klass, *args); end
  def self.enqueue_in(interval, klass, *args); end
  def self.enqueue_to(queue, klass, *args); end
  def self.enqueue_to_in(queue, interval, klass, *args); end
  def self.push(item); end
  def self.push_bulk(items); end
  def self.via(pool); end
  include Sidekiq::JobUtil
end
class Sidekiq::TransactionAwareClient
  def initialize(pool: nil, config: nil); end
  def push(item); end
  def push_bulk(items); end
end
module Sidekiq::Job
  def jid; end
  def jid=(arg0); end
  def logger; end
  def self.clear_all; end
  def self.drain_all; end
  def self.included(base); end
  def self.jobs; end
end
module Sidekiq::Job::Options
  def self.included(base); end
end
module Sidekiq::Job::Options::ClassMethods
  def get_sidekiq_options; end
  def sidekiq_class_attribute(*attrs); end
  def sidekiq_options(opts = nil); end
  def sidekiq_retries_exhausted(&block); end
  def sidekiq_retry_in(&block); end
end
class Sidekiq::Job::Setter
  def at(interval); end
  def initialize(klass, opts); end
  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(args, batch_size: nil); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_sync(*args); end
  def set(options); end
  include Sidekiq::JobUtil
end
module Sidekiq::Job::ClassMethods
  def build_client; end
  def clear; end
  def client_push(item); end
  def delay(*args); end
  def delay_for(*args); end
  def delay_until(*args); end
  def drain; end
  def execute_job(worker, args); end
  def jobs; end
  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(*args, **kwargs); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_one; end
  def perform_sync(*args); end
  def process_job(job); end
  def queue; end
  def queue_as(q); end
  def set(options); end
  def sidekiq_options(opts = nil); end
end
class Sidekiq::Rails < Rails::Engine
end
class Sidekiq::Rails::Reloader
  def call; end
  def initialize(app = nil); end
  def inspect; end
end
class Sidekiq::Shutdown < Interrupt
end
class Sidekiq::Testing
  def self.__set_test_mode(mode); end
  def self.__test_mode; end
  def self.__test_mode=(arg0); end
  def self.disable!(&block); end
  def self.disabled?; end
  def self.enabled?; end
  def self.fake!(&block); end
  def self.fake?; end
  def self.inline!(&block); end
  def self.inline?; end
  def self.server_middleware; end
end
class Sidekiq::EmptyQueueError < RuntimeError
end
module Sidekiq::TestingClient
  def raw_push(payloads); end
end
module Sidekiq::Queues
  def self.[](queue); end
  def self.clear_all; end
  def self.clear_for(queue, klass); end
  def self.delete_for(jid, queue, klass); end
  def self.jobs_by_class; end
  def self.jobs_by_queue; end
  def self.jobs_by_worker; end
  def self.push(queue, klass, job); end
end
module Sidekiq::TestingExtensions
  def jobs_for(klass); end
end
